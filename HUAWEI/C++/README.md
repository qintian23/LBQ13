# 前言


## 特殊函数



## 断言

> 自定义断言

```
/*使用断言测试*/
#ifdef DEBUG
/*处理函数原型*/
void Assert(char * filename, unsigned int lineno);
#define ASSERT(condition)\
if(condition)\
    NULL; \
else\
    Assert(__FILE__ , __LINE__)
/*不使用断言测试*/
#else
#define ASSERT(condition) NULL
#endif
void Assert(char * filename, unsigned int lineno)
{
    fflush(stdout);
    fprintf(stderr,"\nAssert failed： %s, line %u\n",filename, lineno);
    fflush(stderr);
    abort();
}
```

对于防错性程序设计，相信有经验的程序员并不陌生，大多数教科书也都鼓励程序员进行防错性程序设计。在程序设计过程中，总会或多或少产生一些错误，这些错误有些属于设计阶段隐藏下来的，有些则是在编码中产生的。为了避免和纠正这些错误，可在编码过程中有意识地在程序中加进一些错误检查的措施，这就是防错性程序设计的基本思想。其中，它又可以分为主动式防错程序设计和被动式防错程序设计两种。

主动式防错程序设计是指周期性地对整个程序或数据库进行搜查或在空闲时搜查异常情况。它既可以在处理输入信息期间使用，也可以在系统空闲时间或等待下一个输入时使用。如下面所列出的检查均适合主动式防错程序设计。

1. 内存检查：如果在内存的某些块中存放了一些具有某种类型和范围的数据，则可对它们做经常性检查。
2. 标志检查：如果系统的状态是由某些标志指示的，可对这些标志做单独检查。
3. 反向检查：对于一些从一种代码翻译成另一种代码或从一种系统翻译成另一种系统的数据或变量值，可以采用反向检查，即利用反向翻译来检查原始值的翻译是否正确。
4. 状态检查：对于某些具有多个操作状态的复杂系统，若用某些特定的存储值来表示这些状态，则可通过单独检查存储值来验证系统的操作状态。
5. 连接检查：当使用链表结构时，可检查链表的连接情况。
6. 时间检查：如果已知道完成某项计算所需的最长时间，则可用定时器来监视这个时间。
7. 其他检查：程序设计人员可经常仔细地对所使用的数据结构、操作序列和定时以及程序的功能加以考虑，从中得到要进行哪些检查的启发。

被动式防错程序设计则是指必须等到某个输入之后才能进行检查，也就是达到检查点时才能对程序的某些部分进行检查。一般所要进行的检查项目如下：
来自外部设备的输入数据，包括范围、属性是否正确。
由其他程序所提供的数据是否正确。

1. 数据库中的数据，包括数组、文件、结构、记录是否正确。
2. 操作员的输入，包括输入的性质、顺序是否正确。
3. 栈的深度是否正确。
4. 数组界限是否正确。
5. 表达式中是否出现零分母情况。
6. 正在运行的程序版本是否是所期望的（包括最后系统重新组合的日期）。
7. 通过其他程序或外部设备的输出数据是否正确。

虽然防错性程序设计被誉为有较好的编码风格，一直被业界强烈推荐。但防错性程序设计也是一把双刃剑，从调试错误的角度来看，它把原来简单的、显而易见的缺陷转变成晦涩的、难以检测的缺陷，而且诊断起来非常困难。从某种意义上讲，防错性程序设计隐瞒了程序的潜在错误。

当然，对于软件产品，希望它越健壮越好。但是调试脆弱的程序更容易帮助我们发现其问题，因为当缺陷出现的时候它就会立即表现出来。因此，在进行防错性程序设计时，如果“不可能发生”的事情的确发生了，则需要使用断言进行报警，这样，才便于程序员在内部调试阶段及时对程序问题进行处理，从而保证发布的软件产品具有良好的健壮性。
